#!/usr/bin/env ruby

require 'spitball'
require 'optparse'
require 'sinatra'
require 'json'

# cargo culting sinatra's option parser, since it has trouble
# with rubygem stub files

OptionParser.new { |op|
  op.on('-x')        {       set :lock, true }
  op.on('-e env')    { |val| set :environment, val.to_sym }
  op.on('-s server') { |val| set :server, val }
  op.on('-p port')   { |val| set :port, val.to_i }
  op.on('-o addr')   { |val| set :bind, val }
}.parse!(ARGV.dup)

# always run
set :run, true

mime_type :gemfile, 'text/plain'
mime_type :tgz, 'application/x-compressed'

# return json array of cached SHAs
get '/list' do
  content_type :json
  JSON.dump Spitball::Repo.cached_digests
end

# return tgz or gemfile of cached SHA or 404
get '/:digest.:format' do |digest, format|
  error 400 unless ['tgz', 'gemfile'].include? format

  # this returns 404 on Errno::ENOENT
  send_file Spitball::Repo.path(digest, format), :type => format
end

# POST a gemfile. Returns 201 Created if the bundle already exists, or 202 Accepted if it does not. The body of the response is the URI for the tarball.
post '/create' do
  p request.body.read
  request.body.rewind
  ball = Spitball.new(request.body.read)
  url = "#{request.url.split("/create").first}/#{ball.digest}.tgz"
  response['Location'] = url

  if ball.cached?
    status 201
  else
    status 202
    fork { ball.cache! }
  end

  url
end
