#!/usr/bin/env ruby

require 'spitball'
require 'optparse'
require 'sinatra'
require 'json'

# cargo culting sinatra's option parser, since it has trouble
# with rubygem stub files

OptionParser.new { |op|
  op.on('-x')        {       set :lock, true }
  op.on('-e env')    { |val| set :environment, val.to_sym }
  op.on('-s server') { |val| set :server, val }
  op.on('-p port')   { |val| set :port, val.to_i }
  op.on('-o addr')   { |val| set :bind, val }
}.parse!(ARGV.dup)

# always run
set :run, true

mime_type :gemfile, 'text/plain'
mime_type :lock, 'text/plain'
mime_type :tgz, 'application/x-compressed'

# return json array of cached SHAs
get '/list' do
  content_type :json
  JSON.dump Spitball::Repo.cached_digests
end

# return tgz or gemfile of cached SHA or 404
get '/:digest.:format' do |digest, format|
  error 400 unless ['tgz', 'gemfile'].include? format

  # this returns 404 on Errno::ENOENT
  send_file Spitball::Repo.bundle_path(digest, format), :type => format
end

class Streamer
  def initialize(io); @io = io end
  def each; while buf = @io.read(200); yield buf end end
end

# POST a gemfile. Returns 201 Created if the bundle already exists, or
# 202 Accepted if it does not. The body of the response is the URI for
# the tarball.
post '/create' do
  ball = Spitball.new(params['gemfile'], params['gemfile_lock'])
  url = "#{request.url.split("/create").first}/#{ball.digest}.tgz"
  response['Location'] = url

  if ball.cached?
    status 201
    "Bundle tarball pre-cached.\n"
  else
    status 202

    pid = open("|-")

    if pid == nil # child
      begin
        STDOUT.sync = true
        ball.cache!
      rescue Object => e
        puts "#{e.class}: #{e}", e.backtrace.map{|l| "\t#{l}" }
        exit! 1
      end
      exit!
    end

    Streamer.new(pid)
  end
end
